<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="UTF-8">
    <title>UI4 Parser Generator</title>
    <style>
        table {
          border-collapse: collapse;
          border: 1px solid grey;
        }
        table tbody td {
          border-collapse: collapse;
          border: 1px solid grey;
        }
    </style>
    <script src="https://unpkg.com/peggy"></script>
    <script>

        function generateParser() {
            const grammarElem = document.getElementById("grammar");
            const parserElem = document.getElementById("parser")
            const grammar = grammarElem.innerText;
            parserElem.innerText = peggy.generate(grammar, {format: "globals", output: "source"});
            const parser = peggy.generate(grammar);

            testCases.forEach(function (value) {
                const testCase = value[0];
                const shouldMatch = value[1];
                const expectedResult = shouldMatch && JSON.stringify(value[2]);

                const tbody = document.getElementById('tests').getElementsByTagName('tbody')[0];
                const row = tbody.insertRow();

                const cellTestCase = row.insertCell();
                cellTestCase.appendChild(document.createTextNode(testCase));

                const cellShouldMatch = row.insertCell();
                cellShouldMatch.appendChild(document.createTextNode(shouldMatch));

                let didMatch = 'ðŸŸ¢';
                let matchResult = '';
                try {
                    const result = parser.parse(testCase);
                    if (shouldMatch) {
                        matchResult = JSON.stringify(result);
                        if (matchResult !== expectedResult) {
                            didMatch = 'ðŸ”´';
                        }
                    }
                } catch (error) {
                    if (shouldMatch) {
                        didMatch = error.toString();
                    }
                }

                const cellDidMatch = row.insertCell();
                cellDidMatch.appendChild(document.createTextNode(didMatch));

                const cellMatchResult = row.insertCell();
                cellMatchResult.appendChild(document.createTextNode(matchResult));

            });
        }

        const testCases = [

            // FAILURES
            ['left', false],
            ['left=', false],
            ['left=left', false],

            // CALCULATIONS
            ['left=1', true, [{"targetAttribute":"left","comparison":"=","value":1}]],
            ['left=1.9+2.1', true, [{"targetAttribute":"left","comparison":"=","value":4}]],
            ['left=(4-1)*-3', true, [{"targetAttribute":"left","comparison":"=","value":-9}]],

            // FULL CONSTRAINTS
            ['left=root.left', true,
                [{"targetAttribute":"left","comparison":"=", "value":{"id":"root","attribute":"left"}}]
            ],
            ['left=root.left+20', true,
                [{"targetAttribute":"left","comparison":"=",
                    "value":{"operation":"+","lhs":{"id":"root","attribute":"left"},"rhs":20}}]
            ],
            ['width=(root.width-2*gap)/2', true,
                [{"targetAttribute":"width","comparison":"=","value":{
                    "operation":"/","lhs":{
                        "operation":"-","lhs":{"id":"root","attribute":"width"},"rhs":{
                            "operation":"*","lhs":2,"rhs":"gap"
                        }
                    },"rhs":2
                }}]
            ],

            // MIN/MAX
            ['left=max(1,2,3)', true, [{"targetAttribute":"left","comparison":"=","value":3}]],
            ['left=max(20,gap)', true, [{"targetAttribute":"left","comparison":"=",
                "value":{"func":"max","values":[20,"gap"]}}]
            ],
            ['width=min(root.width,root.height)-gap*2', true, [{"targetAttribute":"width","comparison":"=",
                "value":{
                    "operation":"-","lhs":{
                        "func":"min","values":[{"id":"root","attribute":"width"},{"id":"root","attribute":"height"}]},
                        "rhs":{"operation":"*","lhs":"gap","rhs":2}
                    }
                }]
            ],

            // CONDITIONS
            ['portrait?left=1', true, [{"targetAttribute":"left","comparison":"=","value":1,
                "condition":{"aspect":"portrait"}}]],
            ['landscape(root)?left=1', true, [{"targetAttribute":"left","comparison":"=","value":1,
                "condition":{"aspect":"landscape","elemId":"root"}}]],
            ['root.width>root.height+20?left=1', true, [{"targetAttribute":"left","comparison":"=","value":1,
                "condition":{"comparison":">",
                    "lhs":{"id":"root","attribute":"width"},
                    "rhs":{"operation":"+","lhs":{"id":"root","attribute":"height"},"rhs":20}
                }
            }]]
        ];
    </script>

</head>
<body onload="generateParser();">

<h3>Grammar</h3>
<pre id="grammar">

    {
        let result = [];

        const operations = {
            '+': (a, b) => a + b,
            '-': (a, b) => a - b,
            '*': (a, b) => a * b,
            '/': (a, b) => a / b,
            'min': Math.min,
            'max': Math.max
        };

        function checkOperation(op, lhs, rhs) {
            const operation = operations[op];
            if (typeof lhs == 'number' && typeof rhs == 'number') {
                return operation(lhs, rhs);
            } else {
                return {operation: op, lhs: lhs, rhs: rhs};
            }
        }
    }

    constraints
        = constraintSpec* (whitespace constraintSpec)* { return result; }

    constraintSpec
        = condition:condition '?' constraint:constraint { constraint.condition = condition; result.push(constraint); }
          / constraint:constraint { result.push(constraint); }

    constraint 'constraint'
        = targetAttribute:targetAttribute comparison:comparison value:rightHandSide {
            return {targetAttribute: targetAttribute, comparison: comparison, value: value};
          }

    condition
        = aspect:aspect '(' elemId:elemId ')' { return {aspect: aspect, elemId: elemId}; }
        / aspect:aspect { return {aspect: aspect}; }
        / lhs:rightHandSide comparison:comparison rhs:rightHandSide {
            return {comparison: comparison, lhs: lhs, rhs: rhs};
        }

    aspect 'aspect'
        = $ ('portrait' / 'landscape')

    targetAttribute
        = attributeKeyword

    comparison 'comparison'
        = equal / greaterThan / lessThan

    rightHandSide
        = additive

    sourceElemId
        = elemId

    sourceAttribute
        = attributeKeyword

    attributeKeyword 'attribute keyword'
        = edgeKeyword / sizeKeyword / centerKeyword

    edgeKeyword 'edge keyword'
        = 'left' / 'right' / 'top' / 'bottom'

    sizeKeyword 'size keyword'
        = 'width' / 'height'

    centerKeyword 'center keyword'
        = 'centerX' / 'centerY'

    equal 'equal'
        = '='

    greaterThan 'greater than'
        = '>'

    lessThan 'less than'
        = '<'

    elemId 'element id'
        = chars:[a-z0-9]i+ { return text(chars); }

    additive
        = first:multiplicative rest:(("+" / "-") multiplicative)+ {
            return rest.reduce(function(memo, curr) {
              return checkOperation(curr[0], memo, curr[1]);
            }, first);
          }
        / multiplicative

    multiplicative
        = first:primary rest:(("*" / "/") primary)+ {
            return rest.reduce(function(memo, curr) {
              return checkOperation(curr[0], memo, curr[1]);
            }, first);
          }
        / primary

    primary
        = number
        / function
        / sourceValue
        / gap
        / "(" additive:additive ")" { return additive; }

    number 'number'
        = sign:[+-]? integer_part:[0-9]+ period:'.'? decimal_part:[0-9]?
        { return parseFloat(
            sign && text(sign) || '' + text(integer_part) + period || '' + decimal_part && text(decimal_part) || ''
          );
        }

    function 'function'
        = func:('min' / 'max') '(' primaries:primaries ')'
        {
            if (primaries.every((element) => typeof element === 'number')) {
                return operations[func](...primaries);
            } else {
                return {func: func, values: primaries};
            }
        }

    primaries
        = primary:primary ',' primaries:primaries { return [primary].concat(primaries); }
        / primary:primary { return [primary]; }

    sourceValue
        = id:elemId '.' attribute:attributeKeyword { return {id: id, attribute: attribute}; }

    gap
        = 'gap'i

    whitespace 'whitespace'
        = (' ' / '\t' / '\n')+

</pre>

<h3>Tests</h3>
<table id="tests">
    <thead>
        <tr>
            <th>Test case</th><th>Should match</th><th>Match result</th><th>Result</th>
        </tr>
    </thead>
    <tbody>
    </tbody>
</table>

<h3>Parser</h3>
<pre id="parser"></pre>

</body>
</html>
